%\documentclass{report}
\documentclass[11pt,a4paper,notitlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage{titling}
\usepackage{hyperref}

\title{Symbolic execution of adaptive side-channel attacks}
\author{Emilie L. Thonsgaard \and Irfansha Shaik}
\date{May 2020}

\usepackage{natbib}
\usepackage{graphicx}

\begin{document}
\begin{titlingpage}
    \maketitle
    \begin{abstract}
        In this report we review the subject of side-channel attacks and how symbolic execution is used in this context[...]
    \end{abstract}
\end{titlingpage}

\tableofcontents
\newpage
\setcounter{section}{-1}


\section{Todos for IS}
\label{sec:todosforis}

\begin{enumerate}
  \item There does not seem to be major differences in the data produced by heuristics. To be updated in the document.
  \begin{enumerate}
    \item There seems to be difference between heuristics (atleast in data).
    \item Rerunning for small $k$, now the klee does not output all test files (so better).
  \end{enumerate}
  \item Run the script for larger domain size and $k$-step attack.
  \item Run script for different solvers (many option available).
\end{enumerate}

\newpage

\section{Introduction}
\label{cha:introduction}

[...]

\newpage

\section{Literature review}
\label{cha:literaturereview}

XXX

\subsection{Side channel attacks}
\label{sec:sidechannelattacks}

XXX 

\subsection{Symbolic execution}
\label{sec:symbolicexecution}

XXX

\newpage

\section{Research questions}
\label{sec:researchquestions}

Symbolic execution/analysis does result in optimal attack synthesis among other advantages, it is due to all possible paths are modelled into constraints and then analysed.
However, the obvious challenge is that the state space increases exponentially.
Different tools employ different techniques to overcome this well know challenge, now the question here is \emph{What does Klee do differently?}
In the literature XXX add paper, Symbolic Path Finder is a java based symbolic tool was used to analyze the adaptive side channel attack and quantify information leakage.
The SPF implementation of this problem timeout for larger domains and k (XXX add more accurate data) and they employed heuristics to explore some set states to achieve better scalability (to some extent).

In this project, we want to investigate if \texttt{Klee} employ any specific techniques for scalability.
There are several heuristics for exploring the search space and solver chains that can be used.

Investigating solvers chains is essential for symbolic execution, as the most of the time spent is in solver execution.
In this project, for the adaptive side channel attack we investigate the impact of various solvers provided in \texttt{Klee}.

\newpage

\section{Experimentation setup and Analysis}
\label{sec:experimentationanddesign}

To invesigate the scalability of adaptive side channel attacks in \texttt{Klee}, we first model a side channel attack and investigate the adaptive $k$-step attack in \texttt{Klee}.

\subsection{Modelling the adaptive symbolic side channel attack}
\label{subsec:modellingsscattack}

We consider a simple side channel attack via symbolic execution.
Consider the code snippet provided below (source code available in \href{https://github.com/irfansha/LBS_projects.git}{github}):
\begin{verbatim}
int vulnerable_code(int public_input) {

if (secret >= public_input) { return 1; } // Cost is 1
else { return 2; } // Cost is 2

}
\end{verbatim}

As in any side channel attack, we need difference in some measurement (for example time) here we simply provide the cost as integer
for comparision between different paths.

Now the idea is to apply $k$-step attack, such that we extract some information on secret key.
For example, let $\{1 \dots 6\}$ be the domain of the secret (which we assume to know) and suppose we apply a $2$-step attack.
Here, we choose two public inputs such that we slice the domain such that we retrive the secret key depending on the cost measurement.
Given enough $k$, it is possible to retreive the secret key completely however it is not practical as search tree size grows exponentially.
However, if we simply choose $k$ independent public inputs then narrowing down to the secret is very hard.
On the other hand, choosing public inputs based on previous cost observations make it very easy.
For example, for the above example if we choose ${5,6}$ where the costs observed are ${1,2}$ respectively thus the domain is restricted to ${6}$ via ${5,6}$. It is clear that adaptive attacks are very powerful.

The challenge here is to model all possible paths of publich inputs and secret, thus we make them symbolic.
The following is syntax for making variables symbolic in \texttt{Klee}
\begin{verbatim}
// Making the secret symbolic:
klee_make_symbolic(&secret,sizeof(int),"secret");

// Making the public inputs symbolic:
klee_make_symbolic(public_inputs,k * sizeof(int),"public inputs");
\end{verbatim}

Usually symbolic execution is used for synthesis of best side channel attack (we discuss further in outlook section XXX), however here we will only investigate the scalability of \texttt{Klee}.
But it is important to note that in symbolic analysis, which \emph{encodes} all paths in terms of path conditions, it is possible to identify the leakage and thus synthesize best side channel attack.

Now the major challenge is to simulate adaptive attack, in \texttt{Klee} there is no explicit way to specify the bounds of each symbolic variable (that we aware of).
As discussed in the above example the domain of the secret reduces by the pervious cost observations, we model this by left and right bounds (lb, rb) which are updated through out the execution.
Here is the snippet of code that narrows down the secret domain via left and right bounds:
\begin{verbatim}
// Iterate and run `vulnerable function'
for [each k] {
  int cost = vulnerable_function(public_inputs[step]);

  //Here we update the domain boundaries secret input
  if (cost == 1) { rb = public_inputs[step] - 1;}
  else { lb = public_inputs[step]; }

}
\end{verbatim}

\subsection{Software: \texttt{Klee} and our experimentation setup}
\label{subsec:softwares}

\href{https://klee.github.io/}{\texttt{Klee}} is a open source symbolic execution tool that runs on top of LLVM infrastructure.
More details are presented in paper XXX.
Generally used to analyse the coverage of code in C/C++ which is inturn compiled into LLVM. 

Docker usage:
\begin{enumerate}
    \item \texttt{sudo docker run --rm -ti --ulimit='stack=-1:-1' klee/klee}
    \item More information on docker available in \href{http://klee.github.io/releases/docs/v1.3.0/docker/}{github}
\end{enumerate}

Instructions to use for compilation, run and looking at testcases:
\begin{verbatim}
clang -I ../../include -emit-llvm -c -g ./examples/project_proto/symbolic_attack.c
klee -emit-all-errors symbolic_attack.bc 1 6 2
ktest-tool test000018.ktest
\end{verbatim}

We use our adaptive side channel attack model, and investigate different heuristics and solvers provided by \texttt{Klee}.
Here are the list of heuristics we consider:
\begin{enumerate}
\item dfs - uses Depth First Search (DFS)
\item random-state - randomly selects a state to explore
\item random-path - uses Random Path Selection
\item Non Uniform Random Search (NURS):
  \begin{enumerate}
  \item covnew - uses Coverage-New heuristic
  \item md2u - uses Min-Dist-to-Uncovered heuristic
  \item depth - uses $2^d$ ($d$ is depth) heuristic
  \item icnt - uses Instr-Count heuristic
  \item cpicnt - uses CallPath-Instr-Count heuristic
  \item qc- uses Query-Cost heuristic
  \end{enumerate}
\item we also consider no heuristics and all heuristics interleaved.
\end{enumerate}

A key point to remember with the different heuristics is that, they only dictate with symbolic state to expand next.
That implies, a full scale exploration of search trees will not be effected much by the heuristics.
In our experimentation we cut of the trees with certain $k$ so heuristics might play a role here (or not).

Here are the solvers we consider:
\begin{enumerate}
\item STP (XXX provide reference to original paper)
\item Z3 (XXX provide reference)
\item Counter example  caching solver
\item Independence solver
\end{enumerate}

XXX Add few points on each solver.

\subsection{Data and analysis}
\label{subsec:dataandanalysis}

XXX

\newpage

\section{Outlook and future work}
\label{sec:futurework}

Symbolic execution of adaptive side channel attack is an earlier stage of bigger problem i.e., the synthesis of optimal side channel attack.
The natural next step is to use the data produced in section XXX (instead of explicit data, a constraint solver can be used to find right values) and synthesising the public inputs with maximum information leakage.



\bibliographystyle{plain}
\bibliography{references}
\end{document}
